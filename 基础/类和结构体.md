# 目录

   * [类与结构体的对比](#类与结构体的对比)
   * [语法](#语法)
   * [访问属性](#访问属性)
   * [结构体类型的成员初始化器](#结构体类型的成员初始化器)
   * [结构体和枚举是值类型](#结构体和枚举是值类型)
   * [类是引用类型](#类是引用类型)
      * [特征运算符](#特征运算符)
      * [指针](#指针)
   * [类和结构体之间的选择](#类和结构体之间的选择)
   * [字符串，数组和字典的赋值与拷贝行为](#字符串数组和字典的赋值与拷贝行为)

# 类与结构体的对比

共同之处：

- 定义属性用来存储值
- 定义方法用于提供功能
- 定义下标脚本用来允许使用下标语法访问值
- 定义初始化器用于初始化状态
- **可以被扩展来默认所没有的功能**
- **遵循协议来针对特定类型提供标准功能**

类有而结构体没有的额外功能：

* 继承允许一个类继承另一个类的特征
* 类型转换允许你在运行检查和解释一个类实例的类型
* 反初始化器允许一个类实例释放任何其所被分配的资源
* **引用计数允许不止一个对类实例的引用**

# 语法

```swift
class SomeClass {
  // class definition goes here
}  
struct SomeStructure {
  // structure definition goes here
}
```

# 访问属性

使用点(.)语法

> 不同于 Objective-C，Swift 允许你直接设置一个结构体属性中的子属性

# 结构体类型的成员初始化器

所有的结构体都有一个自动生成的**成员初始化器**，你可以使用它来初始化新结构体实例的成员属性。新实例属性的初始化值可以通过属性名称传递到成员初始化器中：

```let vga = Resolution(width: 640, height: 480)```

**与结构体不同，类实例不会接收默认的成员初始化器**

# 结构体和枚举是值类型

**值类型是一种当它被指定到常量或者变量，或者被传递给函数时会被拷贝的类型**

**其实，在之前的章节中我们已经大量使用了值类型。实际上，Swift 中所有的基本类型——整数，浮点数，布尔量，字符串，数组和字典——都是值类型，并且都以结构体的形式在后台实现**

**Swift 中所有的结构体和枚举都是值类型，这意味着你所创建的任何结构体和枚举实例——和实例作为属性所包含的任意值类型——在代码传递中总是被拷贝的**

# 类是引用类型

**不同于值类型，在引用类型被赋值到一个常量，变量或者本身被传递到一个函数的时候它是不会被拷贝的。相对于拷贝，这里使用的是同一个对现存实例的引用**

## 特征运算符

因为类是引用类型，在后台有可能有很多常量和变量都是引用到了同一个类的实例。(相同这词对结构体和枚举来说并不是真的相同，因为它们在赋予给常量，变量或者被传递给一个函数时总是被拷贝过去的。)

有时候找出两个常量或者变量是否引用自同一个类实例非常有用，为了允许这样，Swift提供了两特征运算符：

* 相同于(===)
* 不同于(!==)

利用这两个**恒等运算符**来检查两个常量或者变量是否引用相同的实例：

```swift
if tenEighty === alsoTenEighty {
    print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}
// prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."
```

注意"相同于"(用三个等于号表示，或者说 ===)这与"等于"的意义不同(用两个等于号表示，或者说 ==)

* "相同于"意味着两个类类型常量或者变量引用自相同的实例
* "等于"意味着两个实例的在值上被视作"相等"或者"等价"，某种意义上的"相等"，就如同类设计者定义的那样

## 指针

如果你有过 C，C++ 或者 Objective-C 的经验，你可能知道这些语言使用了*指针*来引用内存中的地址。**一个 Swift 的常量或者变量指向某个实例的引用类型和 C 中的指针类似，但是这并不是直接指向内存地址的指针，也不需要你书写星号( *)来明确你建立了一个引用**。相反，这些引用被定义得就像 Swift 中其他常量或者变量一样

# 类和结构体之间的选择

类和结构体都可以用来定义自定义的数据类型，作为你的程序代码构建块

**总之，结构体实例总是通过*值*来传递，而类实例总是通过*引用*来传递。这意味着他们分别适用于不同类型的任务**

按照通用准则，当符合以下一条或多条情形时应考虑创建一个结构体：

- 结构体的主要目的是为了封装一些相关的简单数据值
- 当你在赋予或者传递结构实例时，有理由需要封装的数据值被拷贝而不是引用
- 任何存储在结构体中的属性是值类型，也将被拷贝而不是被引用
- 结构体不需要从一个已存在类型继承属性或者行为

**在其他的情况下，定义一个类，并创建这个类的实例通过引用来管理和传递**。**事实上，大部分的自定义的数据结构应该是类，而不是结构体**

# 字符串，数组和字典的赋值与拷贝行为

Swift 的 `String` , `Array` 和 `Dictionary`类型是作为结构体来实现的，这意味着字符串，数组和字典在它们被赋值到一个新的常量或者变量，亦或者它们本身被传递到一个函数或方法中的时候，其实是**传递了拷贝**

这种行为不同于`Foundation`库中的 `NSString`, `NSArray`和 `NSDictionary`，它们是作为类来实现的，而不是结构体。 `NSString` , `NSArray` 和`NSDictionary`实例总是作为一个已存在实例的**引用而不是拷贝来赋值和传递**

> 在上述有关字符串，数组和字典"拷贝"的描述中。你在代码中所见到的行为好像总是拷贝。然而在后台 Swift 只有在需要这么做时才会实际去拷贝。Swift 能够管理所有的值的拷贝来确保最佳的性能，所有你也没必要为了保证最佳性能来避免赋值